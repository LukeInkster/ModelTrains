package ModelTrainLanguage.sandbox;

/*Generated by MPS */

import javax.swing.JFrame;
import javax.swing.JPanel;
import java.awt.Graphics;
import java.util.List;
import java.util.ArrayList;
import java.awt.Dimension;
import java.awt.Color;
import java.util.Map;
import java.util.HashMap;

public class map_ModelTrainSet extends JFrame {
  public static double pointGap = 2;
  public static double railWidth = 1;
  public boolean railsCalculated = false;
  public JPanel panel;
  public Graphics graphics;
  private static List<map_ModelTrainSet.TrackSegment> trackPoints = new ArrayList<map_ModelTrainSet.TrackSegment>();
  public static void main(String[] args) {
    map_ModelTrainSet mts = new map_ModelTrainSet();
    mts.init();
  }

  public static class TrackSegment {
    public String self;
    public List<map_ModelTrainSet.Vector3> leftPoints;
    public List<map_ModelTrainSet.Vector3> rightPoints;
    public String from;
    public String to;
    public double angle;
    public TrackSegment(String self, List<map_ModelTrainSet.Vector3> leftPoints, List<map_ModelTrainSet.Vector3> rightPoints, String from, String to, double angle) {
      this.self = self;
      this.leftPoints = leftPoints;
      this.rightPoints = rightPoints;
      this.from = from;
      this.to = to;
      this.angle = angle;
      print("Track: " + self);
      print("Angle: " + angle);
      for (map_ModelTrainSet.Vector3 v : leftPoints) {
      }
      for (map_ModelTrainSet.Vector3 v : rightPoints) {
      }

    }
  }

  public static class Vector3 {
    public double x;
    public double y;
    public double z;
    public Vector3(double x, double y, double z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    public static final map_ModelTrainSet.Vector3 zero = new map_ModelTrainSet.Vector3(0, 0, 0);
    public map_ModelTrainSet.Vector3 subtract(map_ModelTrainSet.Vector3 other) {
      return new map_ModelTrainSet.Vector3(x - other.x, y - other.y, z - other.z);
    }
    public static map_ModelTrainSet.Vector3 midPoint(map_ModelTrainSet.Vector3 a, map_ModelTrainSet.Vector3 b) {
      return new map_ModelTrainSet.Vector3((a.x + b.x) * 0.5f, (a.y + b.y) * 0.5f, (a.z + b.z) * 0.5f);
    }
    public static map_ModelTrainSet.Vector3 add(map_ModelTrainSet.Vector3 a, map_ModelTrainSet.Vector3 b) {
      return new map_ModelTrainSet.Vector3(b.x + a.x, b.y + a.y, b.z + a.z);
    }
    public static map_ModelTrainSet.Vector3 subtract(map_ModelTrainSet.Vector3 a, map_ModelTrainSet.Vector3 b) {
      return new map_ModelTrainSet.Vector3(a.x - b.x, a.y - b.y, a.z - b.z);
    }
    @Override
    public String toString() {
      return "(" + x + "," + y + "," + z + ")";
    }
  }

  public static void addTrackSegment(String self, List<map_ModelTrainSet.Vector3> leftPoints, List<map_ModelTrainSet.Vector3> rightPoints, String from, String to, double angle) {
    trackPoints.add(new map_ModelTrainSet.TrackSegment(self, leftPoints, rightPoints, from, to, angle));
  }
  public static void addTrackSegment(String self, List<map_ModelTrainSet.Vector3> leftPoints, List<map_ModelTrainSet.Vector3> rightPoints, String from, String to) {
    trackPoints.add(new map_ModelTrainSet.TrackSegment(self, leftPoints, rightPoints, from, to, 0));
  }

  public void init() {
    print("AAA");
    final int width = 500;
    final int height = 500;
    trackCreation();
    trackTranslating();
    setTitle("ModelTrain Example Track");
    setDefaultCloseOperation(EXIT_ON_CLOSE);
    panel = new JPanel() {
      @Override
      protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
        trackDrawing(width, height, graphics);
      }
    };
    add(panel);
    panel.setPreferredSize(new Dimension(width, height));
    pack();
    setVisible(true);
  }

  public static map_ModelTrainSet.Vector3 arcCalc(double p, double r, double a) {
    map_ModelTrainSet.Vector3 center = new map_ModelTrainSet.Vector3(0, 0, r);
    map_ModelTrainSet.Vector3 point = new map_ModelTrainSet.Vector3(0, 0, p);
    double d = Math.toRadians(a);
    double x2 = (-Math.sin(d) * (point.z - center.z));
    double y2 = (Math.cos(d) * (point.z - center.z) + center.z);
    return new map_ModelTrainSet.Vector3(x2, 0, y2);
  }

  public class Pair<A, B> {
    public A a;
    public B b;
    public Pair(A a, B b) {
      this.a = a;
      this.b = b;
    }
  }

  public static List<map_ModelTrainSet.Vector3> rotatePoints(List<map_ModelTrainSet.Vector3> points, double angle, map_ModelTrainSet.Vector3 rotPoint) {
    // Rotate list of vectors around a point 
    map_ModelTrainSet.Vector3 center = rotPoint;
    for (map_ModelTrainSet.Vector3 point : points) {
      print("rotate a: " + point + ", rotPoint: " + rotPoint + ", angle: " + angle);
      double a = Math.toRadians(angle);
      double x = (Math.cos(a) * (point.x - center.x) - Math.sin(a) * (point.z - center.z) + center.x);
      double z = (Math.sin(a) * (point.x - center.x) + Math.cos(a) * (point.z - center.z) + center.z);
      point.x = x;
      point.z = z;
      print("rotate b: " + point);
    }
    return points;
  }


  private void trackDrawing(int width, int height, Graphics g) {
    // Loop through all track pieces until all have been drawn 

    // First find range of x,y,z - y currently not used (no height) 
    double xMin = Double.MAX_VALUE;
    double xMax = Double.MIN_VALUE;
    double zMin = Double.MAX_VALUE;
    double zMax = Double.MIN_VALUE;
    for (map_ModelTrainSet.TrackSegment ts : trackPoints) {
      for (map_ModelTrainSet.Vector3 v : ts.leftPoints) {
        xMin = Math.min(v.x, xMin);
        xMax = Math.max(v.x, xMax);
        zMin = Math.min(v.z, zMin);
        zMax = Math.max(v.z, zMax);
      }
      for (map_ModelTrainSet.Vector3 v : ts.rightPoints) {
        xMin = Math.min(v.x, xMin);
        xMax = Math.max(v.x, xMax);
        zMin = Math.min(v.z, zMin);
        zMax = Math.max(v.z, zMax);
      }
    }
    topDown(xMin, xMax, zMin, zMax, width, height, g);
  }

  private void topDown(double xMin, double xMax, double zMin, double zMax, int panelW, int panelH, Graphics g) {
    // Orthagonal projection 
    double width = xMax - xMin;
    double height = zMax - zMin;
    double cx = 0;
    double cy = 0;
    if (xMin < 0) {
      cx = -xMin;
    }
    if (zMin < 0) {
      cy = -zMin;
    }
    int xOff = 10;
    int yOff = 10;
    double sx = 15;
    double sy = 15;
    double x1 = 0;
    double y1 = 0;
    double x2 = 0;
    double y2 = 0;
    int px1 = 0;
    int py1 = 0;
    int px2 = 0;
    int py2 = 0;
    g.setColor(Color.BLACK);
    for (map_ModelTrainSet.TrackSegment ts : trackPoints) {
      print("Track: " + ts.self);
      for (int i = 0; i < ts.leftPoints.size() - 1; i++) {
        print(i + ") left: " + ts.leftPoints.get(i));
        x1 = ts.leftPoints.get(i).x;
        y1 = ts.leftPoints.get(i).z;
        x2 = ts.leftPoints.get(i + 1).x;
        y2 = ts.leftPoints.get(i + 1).z;

        px1 = ((int) (sx * (x1 + cx))) + xOff;
        py1 = ((int) (sy * (y1 + cy))) + yOff;
        px2 = ((int) (sx * (x2 + cx))) + xOff;
        py2 = ((int) (sy * (y2 + cy))) + yOff;


        g.drawLine(px1, py1, px2, py2);

        x1 = ts.rightPoints.get(i).x;
        y1 = ts.rightPoints.get(i).z;
        x2 = ts.rightPoints.get(i + 1).x;
        y2 = ts.rightPoints.get(i + 1).z;

        px1 = ((int) (sx * (x1 + cx))) + xOff;
        py1 = ((int) (sy * (y1 + cy))) + yOff;
        px2 = ((int) (sx * (x2 + cx))) + xOff;
        py2 = ((int) (sy * (y2 + cy))) + yOff;

        g.drawLine(px1, py1, px2, py2);


      }
    }


  }

  private void trackTranslating() {
    // Translate and rotate track pieces into a 3D coordinate system 
    Map<String, map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3>> offsets = new HashMap<String, map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3>>();
    Map<String, map_ModelTrainSet.Pair<Double, Double>> angles = new HashMap<String, map_ModelTrainSet.Pair<Double, Double>>();
    boolean started = false;
    boolean done = false;
    while (!(done)) {
      done = true;
      for (map_ModelTrainSet.TrackSegment ts : trackPoints) {
        if (offsets.containsKey(ts.self)) {
          continue;
        }
        done = false;

        if (!(started)) {
          // Initalise starting position 
          offsets.put(ts.self, new map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3>(map_ModelTrainSet.Vector3.zero, map_ModelTrainSet.Vector3.midPoint(ts.leftPoints.get(ts.leftPoints.size() - 1), ts.rightPoints.get(ts.rightPoints.size() - 1))));
          started = true;
          map_ModelTrainSet.Pair<Double, Double> anglePair = new map_ModelTrainSet.Pair<Double, Double>(0.0, 0.0);
          if (ts.angle != 0) {
            anglePair.b = ts.angle;
          }
          angles.put(ts.self, anglePair);
          continue;
        }

        // Check if this node's from track has been visited 
        map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3> offset = new map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3>(map_ModelTrainSet.Vector3.zero, map_ModelTrainSet.Vector3.zero);
        map_ModelTrainSet.Pair<Double, Double> targetAngles;
        map_ModelTrainSet.Pair<Double, Double> selfAngles;

        if (offsets.containsKey(ts.from)) {
          targetAngles = angles.get(ts.from);
          selfAngles = new map_ModelTrainSet.Pair<Double, Double>(targetAngles.b, targetAngles.b + ts.angle);
          print("f " + selfAngles.a + "," + selfAngles.b);
          if (selfAngles.a != 0) {
            ts.leftPoints = rotatePoints(ts.leftPoints, selfAngles.a, map_ModelTrainSet.Vector3.zero);
            ts.rightPoints = rotatePoints(ts.rightPoints, selfAngles.a, map_ModelTrainSet.Vector3.zero);
          }
          offset.a = offsets.get(ts.from).b;
          offset.b = map_ModelTrainSet.Vector3.add(offset.a, map_ModelTrainSet.Vector3.midPoint(ts.leftPoints.get(ts.leftPoints.size() - 1), ts.rightPoints.get(ts.rightPoints.size() - 1)));
          print("f " + offset.a + "," + offset.b);
        } else if (offsets.containsKey(ts.to)) {
          targetAngles = angles.get(ts.to);
          selfAngles = new map_ModelTrainSet.Pair<Double, Double>(targetAngles.a - ts.angle, targetAngles.a);
          print(selfAngles.a + "," + selfAngles.b);
          map_ModelTrainSet.Vector3 rotatePoint = map_ModelTrainSet.Vector3.midPoint(ts.leftPoints.get(ts.leftPoints.size() - 1), ts.rightPoints.get(ts.rightPoints.size() - 1));
          ts.leftPoints = rotatePoints(ts.leftPoints, selfAngles.b, rotatePoint);
          ts.rightPoints = rotatePoints(ts.rightPoints, selfAngles.b, rotatePoint);
          offset.b = offsets.get(ts.from).a;
          offset.a = map_ModelTrainSet.Vector3.subtract(offset.b, map_ModelTrainSet.Vector3.midPoint(ts.leftPoints.get(0), ts.rightPoints.get(0)));
        } else {
          continue;
        }
        angles.put(ts.self, selfAngles);
        offsets.put(ts.self, offset);

      }
    }
    // Apply offsets 
    for (map_ModelTrainSet.TrackSegment ts : trackPoints) {
      map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3> offset = offsets.get(ts.self);
      print("Track: " + ts.self);
      for (int i = 0; i < ts.leftPoints.size(); i++) {
        print(i + ") Offset: " + offset.a + ", left: " + ts.leftPoints.get(i) + ", right: " + ts.rightPoints.get(i));
        ts.leftPoints.set(i, map_ModelTrainSet.Vector3.add(ts.leftPoints.get(i), offset.a));
        ts.rightPoints.set(i, map_ModelTrainSet.Vector3.add(ts.rightPoints.get(i), offset.a));
      }
    }

  }

  public static void print(Object o) {
    System.out.println(o.toString());
  }

  private void trackCreation() {
    // Turns track pieces into sets of 3d positions 
    {
      // Get names of connecting tracks 
      String track1Name = "10";
      String track2Name = "2";
      String self = "1";

      // Create track segments based on this track piece 
      String len = "5.0f";
      double dLen = 0;
      double dGap = map_ModelTrainSet.pointGap;
      double dWid = map_ModelTrainSet.railWidth;
      try {
        dLen = Double.parseDouble(StringUtils.substring(len, 0, len.length() - 2));
      } catch (NumberFormatException e) {
        System.out.println("Straight Track " + "1" + " has an invalid length: " + len);
      }

      List<map_ModelTrainSet.Vector3> listLeft = new ArrayList<map_ModelTrainSet.Vector3>();
      List<map_ModelTrainSet.Vector3> listRight = new ArrayList<map_ModelTrainSet.Vector3>();
      for (double i = 0; i < dLen; i += dGap) {
        listLeft.add(new map_ModelTrainSet.Vector3(i, 0, -dWid));
        listRight.add(new map_ModelTrainSet.Vector3(i, 0, dWid));

      }
      listLeft.add(new map_ModelTrainSet.Vector3(dLen, 0, -dWid));
      listRight.add(new map_ModelTrainSet.Vector3(dLen, 0, dWid));


      map_ModelTrainSet.addTrackSegment(self, listLeft, listRight, track1Name, track2Name);

    }
    {
      // Get names of connecting tracks 
      String track1Name = "1";
      String track2Name = "3";
      String self = "2";

      // Create track segments based on this track piece 
      String ang = "45.0f";
      String rad = "2.0f";
      double dAng = 0;
      double dRad = 0;
      double dGap = map_ModelTrainSet.pointGap * 0.5;
      double dWid = map_ModelTrainSet.railWidth;
      try {
        dAng = Double.parseDouble(StringUtils.substring(ang, 0, ang.length() - 2));
        dRad = Double.parseDouble(StringUtils.substring(rad, 0, rad.length() - 2));
      } catch (NumberFormatException e) {
        System.out.println("Curved Track " + "2" + " has an invalid angle/radius: " + ang + " " + rad);
      }

      List<map_ModelTrainSet.Vector3> listLeft = new ArrayList<map_ModelTrainSet.Vector3>();
      List<map_ModelTrainSet.Vector3> listRight = new ArrayList<map_ModelTrainSet.Vector3>();

      double dm = dGap;
      if (dAng < 0) {
        dm = -dGap;
      }

      for (double i = 0; Math.abs(i) < Math.abs(dAng); i += dm) {
        listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, i));
        listRight.add(map_ModelTrainSet.arcCalc(1, dRad, i));

      }
      listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, dAng));
      listRight.add(map_ModelTrainSet.arcCalc(1, dRad, dAng));

      System.out.println("angle: " + dAng);
      map_ModelTrainSet.addTrackSegment(self, listLeft, listRight, track1Name, track2Name, dAng);
    }
    {
      // Get names of connecting tracks 
      String track1Name = "2";
      String track2Name = "4";
      String self = "3";

      // Create track segments based on this track piece 
      String ang = "45.0f";
      String rad = "2.0f";
      double dAng = 0;
      double dRad = 0;
      double dGap = map_ModelTrainSet.pointGap * 0.5;
      double dWid = map_ModelTrainSet.railWidth;
      try {
        dAng = Double.parseDouble(StringUtils.substring(ang, 0, ang.length() - 2));
        dRad = Double.parseDouble(StringUtils.substring(rad, 0, rad.length() - 2));
      } catch (NumberFormatException e) {
        System.out.println("Curved Track " + "3" + " has an invalid angle/radius: " + ang + " " + rad);
      }

      List<map_ModelTrainSet.Vector3> listLeft = new ArrayList<map_ModelTrainSet.Vector3>();
      List<map_ModelTrainSet.Vector3> listRight = new ArrayList<map_ModelTrainSet.Vector3>();

      double dm = dGap;
      if (dAng < 0) {
        dm = -dGap;
      }

      for (double i = 0; Math.abs(i) < Math.abs(dAng); i += dm) {
        listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, i));
        listRight.add(map_ModelTrainSet.arcCalc(1, dRad, i));

      }
      listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, dAng));
      listRight.add(map_ModelTrainSet.arcCalc(1, dRad, dAng));

      System.out.println("angle: " + dAng);
      map_ModelTrainSet.addTrackSegment(self, listLeft, listRight, track1Name, track2Name, dAng);
    }
    {
      // Get names of connecting tracks 
      String track1Name = "3";
      String track2Name = "5";
      String self = "4";

      // Create track segments based on this track piece 
      String ang = "45.0f";
      String rad = "2.0f";
      double dAng = 0;
      double dRad = 0;
      double dGap = map_ModelTrainSet.pointGap * 0.5;
      double dWid = map_ModelTrainSet.railWidth;
      try {
        dAng = Double.parseDouble(StringUtils.substring(ang, 0, ang.length() - 2));
        dRad = Double.parseDouble(StringUtils.substring(rad, 0, rad.length() - 2));
      } catch (NumberFormatException e) {
        System.out.println("Curved Track " + "4" + " has an invalid angle/radius: " + ang + " " + rad);
      }

      List<map_ModelTrainSet.Vector3> listLeft = new ArrayList<map_ModelTrainSet.Vector3>();
      List<map_ModelTrainSet.Vector3> listRight = new ArrayList<map_ModelTrainSet.Vector3>();

      double dm = dGap;
      if (dAng < 0) {
        dm = -dGap;
      }

      for (double i = 0; Math.abs(i) < Math.abs(dAng); i += dm) {
        listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, i));
        listRight.add(map_ModelTrainSet.arcCalc(1, dRad, i));

      }
      listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, dAng));
      listRight.add(map_ModelTrainSet.arcCalc(1, dRad, dAng));

      System.out.println("angle: " + dAng);
      map_ModelTrainSet.addTrackSegment(self, listLeft, listRight, track1Name, track2Name, dAng);
    }
    {
      // Get names of connecting tracks 
      String track1Name = "4";
      String track2Name = "6";
      String self = "5";

      // Create track segments based on this track piece 
      String ang = "45.0f";
      String rad = "2.0f";
      double dAng = 0;
      double dRad = 0;
      double dGap = map_ModelTrainSet.pointGap * 0.5;
      double dWid = map_ModelTrainSet.railWidth;
      try {
        dAng = Double.parseDouble(StringUtils.substring(ang, 0, ang.length() - 2));
        dRad = Double.parseDouble(StringUtils.substring(rad, 0, rad.length() - 2));
      } catch (NumberFormatException e) {
        System.out.println("Curved Track " + "5" + " has an invalid angle/radius: " + ang + " " + rad);
      }

      List<map_ModelTrainSet.Vector3> listLeft = new ArrayList<map_ModelTrainSet.Vector3>();
      List<map_ModelTrainSet.Vector3> listRight = new ArrayList<map_ModelTrainSet.Vector3>();

      double dm = dGap;
      if (dAng < 0) {
        dm = -dGap;
      }

      for (double i = 0; Math.abs(i) < Math.abs(dAng); i += dm) {
        listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, i));
        listRight.add(map_ModelTrainSet.arcCalc(1, dRad, i));

      }
      listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, dAng));
      listRight.add(map_ModelTrainSet.arcCalc(1, dRad, dAng));

      System.out.println("angle: " + dAng);
      map_ModelTrainSet.addTrackSegment(self, listLeft, listRight, track1Name, track2Name, dAng);
    }
    {
      // Get names of connecting tracks 
      String track1Name = "5";
      String track2Name = "7";
      String self = "6";

      // Create track segments based on this track piece 
      String len = "5.0f";
      double dLen = 0;
      double dGap = map_ModelTrainSet.pointGap;
      double dWid = map_ModelTrainSet.railWidth;
      try {
        dLen = Double.parseDouble(StringUtils.substring(len, 0, len.length() - 2));
      } catch (NumberFormatException e) {
        System.out.println("Straight Track " + "6" + " has an invalid length: " + len);
      }

      List<map_ModelTrainSet.Vector3> listLeft = new ArrayList<map_ModelTrainSet.Vector3>();
      List<map_ModelTrainSet.Vector3> listRight = new ArrayList<map_ModelTrainSet.Vector3>();
      for (double i = 0; i < dLen; i += dGap) {
        listLeft.add(new map_ModelTrainSet.Vector3(i, 0, -dWid));
        listRight.add(new map_ModelTrainSet.Vector3(i, 0, dWid));

      }
      listLeft.add(new map_ModelTrainSet.Vector3(dLen, 0, -dWid));
      listRight.add(new map_ModelTrainSet.Vector3(dLen, 0, dWid));


      map_ModelTrainSet.addTrackSegment(self, listLeft, listRight, track1Name, track2Name);

    }
    {
      // Get names of connecting tracks 
      String track1Name = "6";
      String track2Name = "8";
      String self = "7";

      // Create track segments based on this track piece 
      String ang = "45.0f";
      String rad = "2.0f";
      double dAng = 0;
      double dRad = 0;
      double dGap = map_ModelTrainSet.pointGap * 0.5;
      double dWid = map_ModelTrainSet.railWidth;
      try {
        dAng = Double.parseDouble(StringUtils.substring(ang, 0, ang.length() - 2));
        dRad = Double.parseDouble(StringUtils.substring(rad, 0, rad.length() - 2));
      } catch (NumberFormatException e) {
        System.out.println("Curved Track " + "7" + " has an invalid angle/radius: " + ang + " " + rad);
      }

      List<map_ModelTrainSet.Vector3> listLeft = new ArrayList<map_ModelTrainSet.Vector3>();
      List<map_ModelTrainSet.Vector3> listRight = new ArrayList<map_ModelTrainSet.Vector3>();

      double dm = dGap;
      if (dAng < 0) {
        dm = -dGap;
      }

      for (double i = 0; Math.abs(i) < Math.abs(dAng); i += dm) {
        listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, i));
        listRight.add(map_ModelTrainSet.arcCalc(1, dRad, i));

      }
      listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, dAng));
      listRight.add(map_ModelTrainSet.arcCalc(1, dRad, dAng));

      System.out.println("angle: " + dAng);
      map_ModelTrainSet.addTrackSegment(self, listLeft, listRight, track1Name, track2Name, dAng);
    }
    {
      // Get names of connecting tracks 
      String track1Name = "7";
      String track2Name = "9";
      String self = "8";

      // Create track segments based on this track piece 
      String ang = "45.0f";
      String rad = "2.0f";
      double dAng = 0;
      double dRad = 0;
      double dGap = map_ModelTrainSet.pointGap * 0.5;
      double dWid = map_ModelTrainSet.railWidth;
      try {
        dAng = Double.parseDouble(StringUtils.substring(ang, 0, ang.length() - 2));
        dRad = Double.parseDouble(StringUtils.substring(rad, 0, rad.length() - 2));
      } catch (NumberFormatException e) {
        System.out.println("Curved Track " + "8" + " has an invalid angle/radius: " + ang + " " + rad);
      }

      List<map_ModelTrainSet.Vector3> listLeft = new ArrayList<map_ModelTrainSet.Vector3>();
      List<map_ModelTrainSet.Vector3> listRight = new ArrayList<map_ModelTrainSet.Vector3>();

      double dm = dGap;
      if (dAng < 0) {
        dm = -dGap;
      }

      for (double i = 0; Math.abs(i) < Math.abs(dAng); i += dm) {
        listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, i));
        listRight.add(map_ModelTrainSet.arcCalc(1, dRad, i));

      }
      listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, dAng));
      listRight.add(map_ModelTrainSet.arcCalc(1, dRad, dAng));

      System.out.println("angle: " + dAng);
      map_ModelTrainSet.addTrackSegment(self, listLeft, listRight, track1Name, track2Name, dAng);
    }
    {
      // Get names of connecting tracks 
      String track1Name = "8";
      String track2Name = "10";
      String self = "9";

      // Create track segments based on this track piece 
      String ang = "45.0f";
      String rad = "2.0f";
      double dAng = 0;
      double dRad = 0;
      double dGap = map_ModelTrainSet.pointGap * 0.5;
      double dWid = map_ModelTrainSet.railWidth;
      try {
        dAng = Double.parseDouble(StringUtils.substring(ang, 0, ang.length() - 2));
        dRad = Double.parseDouble(StringUtils.substring(rad, 0, rad.length() - 2));
      } catch (NumberFormatException e) {
        System.out.println("Curved Track " + "9" + " has an invalid angle/radius: " + ang + " " + rad);
      }

      List<map_ModelTrainSet.Vector3> listLeft = new ArrayList<map_ModelTrainSet.Vector3>();
      List<map_ModelTrainSet.Vector3> listRight = new ArrayList<map_ModelTrainSet.Vector3>();

      double dm = dGap;
      if (dAng < 0) {
        dm = -dGap;
      }

      for (double i = 0; Math.abs(i) < Math.abs(dAng); i += dm) {
        listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, i));
        listRight.add(map_ModelTrainSet.arcCalc(1, dRad, i));

      }
      listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, dAng));
      listRight.add(map_ModelTrainSet.arcCalc(1, dRad, dAng));

      System.out.println("angle: " + dAng);
      map_ModelTrainSet.addTrackSegment(self, listLeft, listRight, track1Name, track2Name, dAng);
    }
    {
      // Get names of connecting tracks 
      String track1Name = "9";
      String track2Name = "1";
      String self = "10";

      // Create track segments based on this track piece 
      String ang = "45.0f";
      String rad = "2.0f";
      double dAng = 0;
      double dRad = 0;
      double dGap = map_ModelTrainSet.pointGap * 0.5;
      double dWid = map_ModelTrainSet.railWidth;
      try {
        dAng = Double.parseDouble(StringUtils.substring(ang, 0, ang.length() - 2));
        dRad = Double.parseDouble(StringUtils.substring(rad, 0, rad.length() - 2));
      } catch (NumberFormatException e) {
        System.out.println("Curved Track " + "10" + " has an invalid angle/radius: " + ang + " " + rad);
      }

      List<map_ModelTrainSet.Vector3> listLeft = new ArrayList<map_ModelTrainSet.Vector3>();
      List<map_ModelTrainSet.Vector3> listRight = new ArrayList<map_ModelTrainSet.Vector3>();

      double dm = dGap;
      if (dAng < 0) {
        dm = -dGap;
      }

      for (double i = 0; Math.abs(i) < Math.abs(dAng); i += dm) {
        listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, i));
        listRight.add(map_ModelTrainSet.arcCalc(1, dRad, i));

      }
      listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, dAng));
      listRight.add(map_ModelTrainSet.arcCalc(1, dRad, dAng));

      System.out.println("angle: " + dAng);
      map_ModelTrainSet.addTrackSegment(self, listLeft, listRight, track1Name, track2Name, dAng);
    }
  }
}
