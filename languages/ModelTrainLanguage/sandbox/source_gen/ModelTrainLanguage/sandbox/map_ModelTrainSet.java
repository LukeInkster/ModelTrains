package ModelTrainLanguage.sandbox;

/*Generated by MPS */

import javax.swing.JFrame;
import javax.swing.JPanel;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.awt.image.BufferedImage;
import java.awt.Graphics2D;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Dimension;

public class map_ModelTrainSet extends JFrame {
  public static double pointGap = 2;
  public static double pointGapCurve = 0.5;
  public static double railWidth = 1;
  public static String switchSuffix = "_switch";
  public static String crossSuffix = "_cross";


  public static int width = 1000;
  public static int height = 700;
  public static double startAngle = 0;
  public JPanel panel;

  private static Map<String, String> trackCross = new HashMap<String, String>();
  private static Map<String, Double> trackCrossAngles = new HashMap<String, Double>();
  private static Map<String, TrackSegment> trackPointsMap = new HashMap<String, TrackSegment>();
  private static Map<String, String> trackCrossSwitchInfo = new HashMap<String, String>();
  private static List<TrackSegment> trackPoints = new ArrayList<TrackSegment>();

  private BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
  private Graphics2D g = (Graphics2D) image.createGraphics();

  public static void main(String[] args) {
    map_ModelTrainSet mts = new map_ModelTrainSet();
    mts.init();
  }

  public void init() {
    Color c = new Color(0, 0, 0, Color.TRANSLUCENT);
    g.setColor(c);
    g.fillRect(0, 0, width, height);
    trackCreation();
    trackCrossSwitchCheck();
    trackTranslating();
    trackDrawing();
    setTitle("ModelTrain - " + "Example_Track");
    setDefaultCloseOperation(EXIT_ON_CLOSE);
    panel = new JPanel() {
      @Override
      protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.drawImage(image, 0, 0, null);
      }
    };
    add(panel);
    panel.setPreferredSize(new Dimension(width, height));
    pack();
    setVisible(true);
  }

  private void trackCrossSwitchCheck() {
    for (TrackSegment ts : trackPoints) {
      if (trackCrossSwitchInfo.containsKey(ts.self + ts.from)) {
        ts.from += trackCrossSwitchInfo.get(ts.self + ts.from);
      } else if (trackCrossSwitchInfo.containsKey(ts.self + ts.to)) {
        ts.to += trackCrossSwitchInfo.get(ts.self + ts.from);
      }
    }
  }

  private void trackDrawing() {
    // Loop through all track pieces until all have been drawn 
    // First find range of x,y,z - y currently not used (no height) 
    double xMin = Double.MAX_VALUE;
    double xMax = Double.MIN_VALUE;
    double zMin = Double.MAX_VALUE;
    double zMax = Double.MIN_VALUE;
    for (TrackSegment ts : trackPoints) {
      for (Vector3 v : ts.leftPoints) {
        xMin = Math.min(v.x, xMin);
        xMax = Math.max(v.x, xMax);
        zMin = Math.min(v.z, zMin);
        zMax = Math.max(v.z, zMax);
      }
      for (Vector3 v : ts.rightPoints) {
        xMin = Math.min(v.x, xMin);
        xMax = Math.max(v.x, xMax);
        zMin = Math.min(v.z, zMin);
        zMax = Math.max(v.z, zMax);
      }
    }
    topDown(xMin, xMax, zMin, zMax);
  }

  private void topDown(double xMin, double xMax, double zMin, double zMax) {
    // Orthogonal projection 
    double cx = -xMin;
    double cy = -zMin;
    int xOff = 10;
    int yOff = 10;
    double sx = 15;
    double sy = 15;
    g.setColor(Color.BLACK);
    for (TrackSegment ts : trackPoints) {
      for (int i = 0; i < ts.leftPoints.size() - 1; i++) {
        double x1 = ts.leftPoints.get(i).x;
        double y1 = ts.leftPoints.get(i).z;
        double x2 = ts.leftPoints.get(i + 1).x;
        double y2 = ts.leftPoints.get(i + 1).z;

        int px1 = (int) (Math.round(sx * (x1 + cx))) + xOff;
        int py1 = (int) (Math.round(sy * (y1 + cy))) + yOff;
        int px2 = (int) (Math.round(sx * (x2 + cx))) + xOff;
        int py2 = (int) (Math.round(sy * (y2 + cy))) + yOff;

        g.drawLine(px1, py1, px2, py2);

        x1 = ts.rightPoints.get(i).x;
        y1 = ts.rightPoints.get(i).z;
        x2 = ts.rightPoints.get(i + 1).x;
        y2 = ts.rightPoints.get(i + 1).z;

        px1 = (int) (Math.round(sx * (x1 + cx))) + xOff;
        py1 = (int) (Math.round(sy * (y1 + cy))) + yOff;
        px2 = (int) (Math.round(sx * (x2 + cx))) + xOff;
        py2 = (int) (Math.round(sy * (y2 + cy))) + yOff;

        g.drawLine(px1, py1, px2, py2);

      }
    }
  }

  private void trackTranslating() {
    Map<String, Double> angles = new HashMap<String, Double>();
    boolean started = false;
    boolean done = false;
    int doneCounter = 0;
    int doneLimit = 15;
    while (!(done) && doneCounter < doneLimit) {
      done = true;
      for (TrackSegment ts : trackPoints) {
        if (angles.containsKey(ts.self)) {
          continue;
        }
        done = false;

        if (!(started)) {
          angles.put(ts.self, startAngle);
          started = true;
          continue;
        }
        String dir = "- F";
        TrackSegment target;
        double angle;
        Vector3 targetPositionL;
        Vector3 targetPositionR;
        Vector3 originPositionL;
        Vector3 originPositionR;

        if (angles.containsKey(ts.from)) {
          target = trackPointsMap.get(ts.from);
          originPositionL = ts.leftPoints.get(0);
          originPositionR = ts.rightPoints.get(0);
          if (target.from.equals(ts.self)) {
            dir += "F";
            angle = 180 + angles.get(target.self);
            targetPositionL = target.rightPoints.get(0);
            targetPositionR = target.leftPoints.get(0);
          } else {
            dir += "T";
            angle = angles.get(target.self) + target.angle;
            targetPositionL = target.leftPoints.get(target.leftPoints.size() - 1);
            targetPositionR = target.rightPoints.get(target.rightPoints.size() - 1);
          }
        } else if (angles.containsKey(ts.to)) {
          dir = "- T";
          target = trackPointsMap.get(ts.to);
          originPositionL = ts.leftPoints.get(ts.leftPoints.size() - 1);
          originPositionR = ts.rightPoints.get(ts.rightPoints.size() - 1);
          if (target.to.equals(ts.self)) {
            dir += "T";
            angle = angles.get(target.self) + target.angle + 180 - ts.angle;
            targetPositionL = target.rightPoints.get(target.rightPoints.size() - 1);
            targetPositionR = target.leftPoints.get(target.leftPoints.size() - 1);
          } else {
            dir += "F";
            angle = angles.get(target.self) - ts.angle;
            targetPositionL = target.leftPoints.get(0);
            targetPositionR = target.rightPoints.get(0);
          }
        } else {
          continue;
        }
        while (angle > 360) {
          angle -= 360;
        }
        while (angle < -360) {
          angle += 360;
        }
        angles.put(ts.self, angle);

        ts.leftPoints = rotatePoints(ts.leftPoints, angle, Vector3.zero);
        ts.rightPoints = rotatePoints(ts.rightPoints, angle, Vector3.zero);
        Vector3 offsetL = Vector3.subtract(targetPositionL, originPositionL);
        Vector3 offsetR = Vector3.subtract(targetPositionR, originPositionR);
        ts.leftPoints = movePoints(ts.leftPoints, offsetL);
        ts.rightPoints = movePoints(ts.rightPoints, offsetR);
        print("Track: " + ts.self + dir);
        print("From: Left" + ts.leftPoints.get(0) + ", Right: " + ts.rightPoints.get(0));
        print("  To: Left" + ts.leftPoints.get(ts.leftPoints.size() - 1) + ", Right: " + ts.rightPoints.get(ts.rightPoints.size() - 1));
        print("Angle: " + angle + "," + (angle + ts.angle));

        // Handle cross and switch track 
        String tsCrossName = "";
        if (trackCross.containsKey(ts.self)) {
          tsCrossName = trackCross.get(ts.self);
        } else if (trackCross.containsValue(ts.self)) {
          tsCrossName = StringUtils.substring(ts.self, ts.self.length() - 1 - crossSuffix.length(), ts.self.length() - 1);
        }
        if (!(tsCrossName.equals(""))) {
          TrackSegment tsCross = trackPointsMap.get(tsCrossName);
          tsCross.leftPoints = rotatePoints(tsCross.leftPoints, angle, Vector3.zero);
          tsCross.rightPoints = rotatePoints(tsCross.rightPoints, angle, Vector3.zero);
          Vector3 moveTo = Vector3.midPoint(ts.leftPoints.get(0), ts.rightPoints.get(0));
          tsCross.leftPoints = movePoints(tsCross.leftPoints, moveTo);
          tsCross.rightPoints = movePoints(tsCross.rightPoints, moveTo);
          angle += trackCrossAngles.get(tsCrossName);
          angles.put(tsCross.self, angle);
          angle = trackCrossAngles.get(tsCrossName);
          Vector3 center = Vector3.midPoint(Vector3.midPoint(tsCross.leftPoints.get(0), tsCross.rightPoints.get(0)), Vector3.midPoint(tsCross.leftPoints.get(tsCross.leftPoints.size() - 1), tsCross.rightPoints.get(tsCross.rightPoints.size() - 1)));
          tsCross.leftPoints = rotatePoints(tsCross.leftPoints, angle, center);
          tsCross.rightPoints = rotatePoints(tsCross.rightPoints, angle, center);
          print("Track: " + tsCross.self);
          print("From: Left" + tsCross.leftPoints.get(0) + ", Right: " + tsCross.rightPoints.get(0));
          print("  To: Left" + tsCross.leftPoints.get(tsCross.leftPoints.size() - 1) + ", Right: " + tsCross.rightPoints.get(tsCross.rightPoints.size() - 1));
          print("Angle: " + angles.get(tsCross.self));
        }

        String tsSwitchName = "";
        if (trackPointsMap.containsKey(ts.self + switchSuffix)) {
          tsSwitchName = ts.self + switchSuffix;
        } else if (trackPointsMap.containsKey(StringUtils.substring(ts.self, ts.self.length() - 1 - switchSuffix.length(), ts.self.length() - 1))) {
          tsSwitchName = StringUtils.substring(ts.self, ts.self.length() - 1 - switchSuffix.length(), ts.self.length() - 1);
        }
        if (!(tsSwitchName.equals(""))) {
          TrackSegment tsSwitch = trackPointsMap.get(tsSwitchName);
          tsSwitch.leftPoints = rotatePoints(tsSwitch.leftPoints, angle, Vector3.zero);
          tsSwitch.rightPoints = rotatePoints(tsSwitch.rightPoints, angle, Vector3.zero);
          offsetL = Vector3.subtract(ts.leftPoints.get(0), tsSwitch.leftPoints.get(0));
          offsetR = Vector3.subtract(ts.rightPoints.get(0), tsSwitch.rightPoints.get(0));
          tsSwitch.leftPoints = movePoints(tsSwitch.leftPoints, offsetL);
          tsSwitch.rightPoints = movePoints(tsSwitch.rightPoints, offsetR);
          angles.put(tsSwitch.self, angles.get(ts.self));
          print("Track: " + tsSwitch.self);
          print("From: Left" + tsSwitch.leftPoints.get(0) + ", Right: " + tsSwitch.rightPoints.get(0));
          print("  To: Left" + tsSwitch.leftPoints.get(tsSwitch.leftPoints.size() - 1) + ", Right: " + tsSwitch.rightPoints.get(tsSwitch.rightPoints.size() - 1));
          print("Angle: " + angle);

        }
      }
      doneCounter += 1;
    }
  }

  public static Vector3 arcCalc(double p, double r, double a) {
    Vector3 center = new Vector3(0, 0, r);
    Vector3 point = new Vector3(0, 0, p);
    double d = Math.toRadians(a);
    double x2 = (-Math.sin(d) * (point.z - center.z));
    double y2 = (Math.cos(d) * (point.z - center.z) + center.z);
    return new Vector3(x2, 0, y2);
  }

  public static List<Vector3> rotatePoints(List<Vector3> points, double angle, Vector3 rotPoint) {
    // Rotate list of vectors around a point 
    if (angle == 0) {
      return points;
    }
    Vector3 center = rotPoint;
    for (Vector3 point : points) {
      double a = Math.toRadians(angle);
      double x = (Math.cos(a) * (point.x - center.x) - Math.sin(a) * (point.z - center.z) + center.x);
      double z = (Math.sin(a) * (point.x - center.x) + Math.cos(a) * (point.z - center.z) + center.z);
      point.x = x;
      point.z = z;
    }
    return points;
  }
  public static List<Vector3> movePoints(List<Vector3> points, Vector3 offset) {
    for (int i = 0; i < points.size(); i++) {
      points.set(i, Vector3.add(points.get(i), offset));
    }
    return points;
  }


  /**
   * Helper methods and classes, and lastly code generated from track structures
   */
  public static void print(Object o) {
    System.out.println(o.toString());
  }


  public static void addTrackCross(String t1, String t2, double angle) {
    trackCross.put(t1, t2);
    trackCrossAngles.put(t1, -angle);
    trackCrossAngles.put(t2, angle);
  }

  public static void addTrackSegment(String self, List<Vector3> leftPoints, List<Vector3> rightPoints, String from, String to, double angle) {
    TrackSegment s = new TrackSegment(self, leftPoints, rightPoints, from, to, angle);
    trackPoints.add(s);
    trackPointsMap.put(self, s);
  }
  public static void addTrackSegment(String self, List<Vector3> leftPoints, List<Vector3> rightPoints, String from, String to) {
    addTrackSegment(self, leftPoints, rightPoints, from, to, 0);
  }

  public static void addCrossSwitchInfo(String key, String value) {
    trackCrossSwitchInfo.put(key, value);
  }


  private void trackCreation() {
    // Turns track pieces into sets of 3d positions 
    {
      String self = "1";
      String track1Name = "Z";
      String track2Name = "Z";
      double dGap = map_ModelTrainSet.pointGapCurve;
      double dWid = map_ModelTrainSet.railWidth;
      double dAng = Double.parseDouble("15");
      double dRad = Double.parseDouble("5");
      List<Vector3> listLeft = new ArrayList<Vector3>();
      List<Vector3> listRight = new ArrayList<Vector3>();
      double dm = dGap;
      if (dAng < 0) {
        dm = -dGap;
        dRad = -dRad;
      }
      for (double i = 0; Math.abs(i) < Math.abs(dAng); i += dm) {
        listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, i));
        listRight.add(map_ModelTrainSet.arcCalc(1, dRad, i));
      }
      listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, dAng));
      listRight.add(map_ModelTrainSet.arcCalc(1, dRad, dAng));
      map_ModelTrainSet.addTrackSegment(self, listLeft, listRight, track1Name, track2Name, dAng);
    }
    {
      String self = "2";
      String switchSuffix = map_ModelTrainSet.switchSuffix;
      boolean left = false;
      String track1Name = "Z";
      String track2Name = "Z";
      String track3Name = "Z";
      double dAng = 45;
      double dRad = 10;
      double dLen = 8;
      double dGapC = map_ModelTrainSet.pointGapCurve;
      double dGap = map_ModelTrainSet.pointGap;
      double dWid = map_ModelTrainSet.railWidth;
      List<Vector3> listLeft = new ArrayList<Vector3>();
      List<Vector3> listRight = new ArrayList<Vector3>();
      double dm = dGapC;
      if (dAng < 0) {
        dm = -dGapC;
      }
      for (double i = 0; Math.abs(i) < Math.abs(dAng); i += dm) {
        listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, i));
        listRight.add(map_ModelTrainSet.arcCalc(1, dRad, i));
      }
      listLeft.add(map_ModelTrainSet.arcCalc(-1, dRad, dAng));
      listRight.add(map_ModelTrainSet.arcCalc(1, dRad, dAng));
      map_ModelTrainSet.addTrackSegment(self + switchSuffix, listLeft, listRight, track1Name, track3Name, dAng);
      map_ModelTrainSet.addCrossSwitchInfo(track3Name + self, switchSuffix);
      map_ModelTrainSet.addCrossSwitchInfo(track1Name + self, switchSuffix);
      listLeft = new ArrayList<Vector3>();
      listRight = new ArrayList<Vector3>();
      for (double i = 0; i < dLen; i += dGap) {
        listLeft.add(new Vector3(i, 0, -dWid));
        listRight.add(new Vector3(i, 0, dWid));
      }
      listLeft.add(new Vector3(dLen, 0, -dWid));
      listRight.add(new Vector3(dLen, 0, dWid));
      map_ModelTrainSet.addTrackSegment(self, listLeft, listRight, track1Name, track2Name, 0);
    }
    // Draw buffers or something 
  }
}
