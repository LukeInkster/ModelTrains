package ModelTrainLanguage.sandbox;

/*Generated by MPS */

import javax.swing.JFrame;
import javax.swing.JPanel;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.awt.image.BufferedImage;
import java.awt.Graphics2D;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Dimension;

public class map_ModelTrainSet extends JFrame {
  public static double pointGap = 2;
  public static double pointGapCurve = 0.5;
  public static double railWidth = 1;
  public static String switchSuffix = "_switch";
  public static String crossSuffix = "_cross";

  public static int width = 1000;
  public static int height = 700;
  public static double startAngle = 0;
  public JPanel panel;

  private static Map<String, String> trackCross = new HashMap<String, String>();
  private static Map<String, Double> trackCrossAngles = new HashMap<String, Double>();
  private static Map<String, map_ModelTrainSet.TrackSegment> trackPointsMap = new HashMap<String, map_ModelTrainSet.TrackSegment>();
  private static List<map_ModelTrainSet.TrackSegment> trackPoints = new ArrayList<map_ModelTrainSet.TrackSegment>();

  private BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
  private Graphics2D g = (Graphics2D) image.createGraphics();

  public static void main(String[] args) {
    map_ModelTrainSet mts = new map_ModelTrainSet();
    mts.init();
  }

  public void init() {
    g.setColor(Color.gray);
    g.fillRect(0, 0, width, height);
    trackCreation();
    trackTranslating();
    trackDrawing();
    setTitle("ModelTrain - " + "Test_Example_SimpleLoop");
    setDefaultCloseOperation(EXIT_ON_CLOSE);
    panel = new JPanel() {
      @Override
      protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.drawImage(image, 0, 0, null);
      }
    };
    add(panel);
    panel.setPreferredSize(new Dimension(width, height));
    pack();
    setVisible(true);
  }


  private void trackDrawing() {
    // Loop through all track pieces until all have been drawn 
    // First find range of x,y,z - y currently not used (no height) 
    double xMin = Double.MAX_VALUE;
    double xMax = Double.MIN_VALUE;
    double zMin = Double.MAX_VALUE;
    double zMax = Double.MIN_VALUE;
    for (map_ModelTrainSet.TrackSegment ts : trackPoints) {
      for (map_ModelTrainSet.Vector3 v : ts.leftPoints) {
        xMin = Math.min(v.x, xMin);
        xMax = Math.max(v.x, xMax);
        zMin = Math.min(v.z, zMin);
        zMax = Math.max(v.z, zMax);
      }
      for (map_ModelTrainSet.Vector3 v : ts.rightPoints) {
        xMin = Math.min(v.x, xMin);
        xMax = Math.max(v.x, xMax);
        zMin = Math.min(v.z, zMin);
        zMax = Math.max(v.z, zMax);
      }
    }
    topDown(xMin, xMax, zMin, zMax);
  }

  private void topDown(double xMin, double xMax, double zMin, double zMax) {
    // Orthogonal projection 
    double cx = -xMin;
    double cy = -zMin;
    int xOff = 10;
    int yOff = 10;
    double sx = 15;
    double sy = 15;
    g.setColor(Color.BLACK);
    for (map_ModelTrainSet.TrackSegment ts : trackPoints) {
      for (int i = 0; i < ts.leftPoints.size() - 1; i++) {
        double x1 = ts.leftPoints.get(i).x;
        double y1 = ts.leftPoints.get(i).z;
        double x2 = ts.leftPoints.get(i + 1).x;
        double y2 = ts.leftPoints.get(i + 1).z;

        int px1 = (int) (Math.round(sx * (x1 + cx))) + xOff;
        int py1 = (int) (Math.round(sy * (y1 + cy))) + yOff;
        int px2 = (int) (Math.round(sx * (x2 + cx))) + xOff;
        int py2 = (int) (Math.round(sy * (y2 + cy))) + yOff;

        g.drawLine(px1, py1, px2, py2);

        x1 = ts.rightPoints.get(i).x;
        y1 = ts.rightPoints.get(i).z;
        x2 = ts.rightPoints.get(i + 1).x;
        y2 = ts.rightPoints.get(i + 1).z;

        px1 = (int) (Math.round(sx * (x1 + cx))) + xOff;
        py1 = (int) (Math.round(sy * (y1 + cy))) + yOff;
        px2 = (int) (Math.round(sx * (x2 + cx))) + xOff;
        py2 = (int) (Math.round(sy * (y2 + cy))) + yOff;

        g.drawLine(px1, py1, px2, py2);

      }
    }
  }

  private void trackTranslating() {
    Map<String, Double> angles = new HashMap<String, Double>();
    boolean started = false;
    boolean done = false;
    int doneCounter = 0;
    int doneLimit = 15;
    while (!(done) && doneCounter < doneLimit) {
      done = true;
      for (map_ModelTrainSet.TrackSegment ts : trackPoints) {
        if (angles.containsKey(ts.self)) {
          continue;
        }
        done = false;

        if (!(started)) {
          angles.put(ts.self, startAngle);
          started = true;
          continue;
        }
        String dir = "- F";
        map_ModelTrainSet.TrackSegment target;
        double angle;
        map_ModelTrainSet.Vector3 targetPositionL;
        map_ModelTrainSet.Vector3 targetPositionR;
        map_ModelTrainSet.Vector3 originPositionL;
        map_ModelTrainSet.Vector3 originPositionR;

        if (angles.containsKey(ts.from)) {
          target = trackPointsMap.get(ts.from);
          originPositionL = ts.leftPoints.get(0);
          originPositionR = ts.rightPoints.get(0);
          if (target.from.equals(ts.self)) {
            dir += "F";
            angle = 180 + angles.get(target.self);
            targetPositionL = target.rightPoints.get(0);
            targetPositionR = target.leftPoints.get(0);
          } else {
            dir += "T";
            angle = angles.get(target.self) + target.angle;
            targetPositionL = target.leftPoints.get(target.leftPoints.size() - 1);
            targetPositionR = target.rightPoints.get(target.rightPoints.size() - 1);
          }
        } else if (angles.containsKey(ts.to)) {
          dir = "- T";
          target = trackPointsMap.get(ts.to);
          originPositionL = ts.leftPoints.get(ts.leftPoints.size() - 1);
          originPositionR = ts.rightPoints.get(ts.rightPoints.size() - 1);
          if (target.to.equals(ts.self)) {
            dir += "T";
            angle = angles.get(target.self) + target.angle + 180 - ts.angle;
            targetPositionL = target.rightPoints.get(target.rightPoints.size() - 1);
            targetPositionR = target.leftPoints.get(target.leftPoints.size() - 1);
          } else {
            dir += "F";
            angle = angles.get(target.self) - ts.angle;
            targetPositionL = target.leftPoints.get(0);
            targetPositionR = target.rightPoints.get(0);
          }
        } else {
          continue;
        }
        while (angle > 360) {
          angle -= 360;
        }
        while (angle < -360) {
          angle += 360;
        }
        angles.put(ts.self, angle);

        ts.leftPoints = rotatePoints(ts.leftPoints, angle, map_ModelTrainSet.Vector3.zero);
        ts.rightPoints = rotatePoints(ts.rightPoints, angle, map_ModelTrainSet.Vector3.zero);
        map_ModelTrainSet.Vector3 offsetL = map_ModelTrainSet.Vector3.subtract(targetPositionL, originPositionL);
        map_ModelTrainSet.Vector3 offsetR = map_ModelTrainSet.Vector3.subtract(targetPositionR, originPositionR);
        ts.leftPoints = movePoints(ts.leftPoints, offsetL);
        ts.rightPoints = movePoints(ts.rightPoints, offsetR);
        print("Track: " + ts.self + dir);
        print("From: Left" + ts.leftPoints.get(0) + ", Right: " + ts.rightPoints.get(0));
        print("  To: Left" + ts.leftPoints.get(ts.leftPoints.size() - 1) + ", Right: " + ts.rightPoints.get(ts.rightPoints.size() - 1));
        print("Angle: " + angle + "," + (angle + ts.angle));

        // Handle cross and switch track 
        String tsCrossName = "";
        if (trackCross.containsKey(ts.self)) {
          tsCrossName = trackCross.get(ts.self);
        } else if (trackCross.containsValue(ts.self)) {
          tsCrossName = StringUtils.substring(ts.self, ts.self.length() - 1 - crossSuffix.length(), ts.self.length() - 1);
        }
        if (!(tsCrossName.equals(""))) {
          map_ModelTrainSet.TrackSegment tsCross = trackPointsMap.get(tsCrossName);
          tsCross.leftPoints = rotatePoints(tsCross.leftPoints, angle, map_ModelTrainSet.Vector3.zero);
          tsCross.rightPoints = rotatePoints(tsCross.rightPoints, angle, map_ModelTrainSet.Vector3.zero);
          map_ModelTrainSet.Vector3 moveTo = map_ModelTrainSet.Vector3.midPoint(ts.leftPoints.get(0), ts.rightPoints.get(0));
          tsCross.leftPoints = movePoints(tsCross.leftPoints, moveTo);
          tsCross.rightPoints = movePoints(tsCross.rightPoints, moveTo);
          angle += trackCrossAngles.get(tsCrossName);
          angles.put(tsCross.self, angle);
          angle = trackCrossAngles.get(tsCrossName);
          map_ModelTrainSet.Vector3 center = map_ModelTrainSet.Vector3.midPoint(map_ModelTrainSet.Vector3.midPoint(tsCross.leftPoints.get(0), tsCross.rightPoints.get(0)), map_ModelTrainSet.Vector3.midPoint(tsCross.leftPoints.get(tsCross.leftPoints.size() - 1), tsCross.rightPoints.get(tsCross.rightPoints.size() - 1)));
          tsCross.leftPoints = rotatePoints(tsCross.leftPoints, angle, center);
          tsCross.rightPoints = rotatePoints(tsCross.rightPoints, angle, center);
          print("Track: " + tsCross.self);
          print("From: Left" + tsCross.leftPoints.get(0) + ", Right: " + tsCross.rightPoints.get(0));
          print("  To: Left" + tsCross.leftPoints.get(tsCross.leftPoints.size() - 1) + ", Right: " + tsCross.rightPoints.get(tsCross.rightPoints.size() - 1));
          print("Angle: " + angles.get(tsCross.self));
        }

        String tsSwitchName = "";
        if (trackPointsMap.containsKey(ts.self + switchSuffix)) {
          tsSwitchName = ts.self + switchSuffix;
        } else if (trackPointsMap.containsKey(StringUtils.substring(ts.self, ts.self.length() - 1 - switchSuffix.length(), ts.self.length() - 1))) {
          tsSwitchName = StringUtils.substring(ts.self, ts.self.length() - 1 - switchSuffix.length(), ts.self.length() - 1);
        }
        if (!(tsSwitchName.equals(""))) {
          map_ModelTrainSet.TrackSegment tsSwitch = trackPointsMap.get(tsSwitchName);
          tsSwitch.leftPoints = rotatePoints(tsSwitch.leftPoints, angle, map_ModelTrainSet.Vector3.zero);
          tsSwitch.rightPoints = rotatePoints(tsSwitch.rightPoints, angle, map_ModelTrainSet.Vector3.zero);
          offsetL = map_ModelTrainSet.Vector3.subtract(ts.leftPoints.get(0), tsSwitch.leftPoints.get(0));
          offsetR = map_ModelTrainSet.Vector3.subtract(ts.rightPoints.get(0), tsSwitch.rightPoints.get(0));
          tsSwitch.leftPoints = movePoints(tsSwitch.leftPoints, offsetL);
          tsSwitch.rightPoints = movePoints(tsSwitch.rightPoints, offsetR);
          angles.put(tsSwitch.self, angles.get(ts.self));
          print("Track: " + tsSwitch.self);
          print("From: Left" + tsSwitch.leftPoints.get(0) + ", Right: " + tsSwitch.rightPoints.get(0));
          print("  To: Left" + tsSwitch.leftPoints.get(tsSwitch.leftPoints.size() - 1) + ", Right: " + tsSwitch.rightPoints.get(tsSwitch.rightPoints.size() - 1));
          print("Angle: " + angle);

        }
      }


      doneCounter += 1;
    }
  }

  public static map_ModelTrainSet.Vector3 arcCalc(double p, double r, double a) {
    map_ModelTrainSet.Vector3 center = new map_ModelTrainSet.Vector3(0, 0, r);
    map_ModelTrainSet.Vector3 point = new map_ModelTrainSet.Vector3(0, 0, p);
    double d = Math.toRadians(a);
    double x2 = (-Math.sin(d) * (point.z - center.z));
    double y2 = (Math.cos(d) * (point.z - center.z) + center.z);
    return new map_ModelTrainSet.Vector3(x2, 0, y2);
  }

  public static List<map_ModelTrainSet.Vector3> rotatePoints(List<map_ModelTrainSet.Vector3> points, double angle, map_ModelTrainSet.Vector3 rotPoint) {
    // Rotate list of vectors around a point 
    if (angle == 0) {
      return points;
    }
    map_ModelTrainSet.Vector3 center = rotPoint;
    for (map_ModelTrainSet.Vector3 point : points) {
      double a = Math.toRadians(angle);
      double x = (Math.cos(a) * (point.x - center.x) - Math.sin(a) * (point.z - center.z) + center.x);
      double z = (Math.sin(a) * (point.x - center.x) + Math.cos(a) * (point.z - center.z) + center.z);
      point.x = x;
      point.z = z;
    }
    return points;
  }
  public static List<map_ModelTrainSet.Vector3> movePoints(List<map_ModelTrainSet.Vector3> points, map_ModelTrainSet.Vector3 offset) {
    for (int i = 0; i < points.size(); i++) {
      points.set(i, map_ModelTrainSet.Vector3.add(points.get(i), offset));
    }
    return points;
  }


  /**
   * Helper methods and classes, and lastly code generated from track structures
   */
  public static void print(Object o) {
    System.out.println(o.toString());
  }


  public static void addTrackCross(String t1, String t2, double angle) {
    trackCross.put(t1, t2);
    trackCrossAngles.put(t1, -angle);
    trackCrossAngles.put(t2, angle);
  }

  public static void addTrackSegment(String self, List<map_ModelTrainSet.Vector3> leftPoints, List<map_ModelTrainSet.Vector3> rightPoints, String from, String to, double angle) {
    map_ModelTrainSet.TrackSegment s = new map_ModelTrainSet.TrackSegment(self, leftPoints, rightPoints, from, to, angle);
    trackPoints.add(s);
    trackPointsMap.put(self, s);
  }
  public static void addTrackSegment(String self, List<map_ModelTrainSet.Vector3> leftPoints, List<map_ModelTrainSet.Vector3> rightPoints, String from, String to) {
    addTrackSegment(self, leftPoints, rightPoints, from, to, 0);
  }

  public class Pair<A, B> {
    public A a;
    public B b;
    public Pair(A a, B b) {
      this.a = a;
      this.b = b;
    }
  }

  public static class Vector3 {
    public double x;
    public double y;
    public double z;
    public Vector3(double x, double y, double z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    public static final map_ModelTrainSet.Vector3 zero = new map_ModelTrainSet.Vector3(0, 0, 0);
    public map_ModelTrainSet.Vector3 subtract(map_ModelTrainSet.Vector3 other) {
      return new map_ModelTrainSet.Vector3(x - other.x, y - other.y, z - other.z);
    }
    public static map_ModelTrainSet.Vector3 midPoint(map_ModelTrainSet.Vector3 a, map_ModelTrainSet.Vector3 b) {
      return new map_ModelTrainSet.Vector3((a.x + b.x) * 0.5f, (a.y + b.y) * 0.5f, (a.z + b.z) * 0.5f);
    }
    public static map_ModelTrainSet.Vector3 add(map_ModelTrainSet.Vector3 a, map_ModelTrainSet.Vector3 b) {
      return new map_ModelTrainSet.Vector3(b.x + a.x, b.y + a.y, b.z + a.z);
    }
    public static map_ModelTrainSet.Vector3 subtract(map_ModelTrainSet.Vector3 a, map_ModelTrainSet.Vector3 b) {
      return new map_ModelTrainSet.Vector3(a.x - b.x, a.y - b.y, a.z - b.z);
    }
    @Override
    public String toString() {
      return "(" + x + "," + y + "," + z + ")";
    }
  }

  public static class TrackSegment {
    public String self;
    public List<map_ModelTrainSet.Vector3> leftPoints;
    public List<map_ModelTrainSet.Vector3> rightPoints;
    public String from;
    public String to;
    public double angle;
    public TrackSegment(String self, List<map_ModelTrainSet.Vector3> leftPoints, List<map_ModelTrainSet.Vector3> rightPoints, String from, String to, double angle) {
      this.self = self;
      this.leftPoints = leftPoints;
      this.rightPoints = rightPoints;
      this.from = from;
      this.to = to;
      this.angle = angle;
    }
  }


  private void trackCreation() {
    // Turns track pieces into sets of 3d positions 
  }
}
