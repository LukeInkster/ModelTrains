package ModelTrainLanguage.sandbox;

/*Generated by MPS */

import javax.swing.JFrame;
import javax.swing.JPanel;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.awt.Graphics;
import java.awt.Dimension;
import java.awt.Color;
import java.util.Set;
import java.util.HashSet;

public class map_ModelTrainSet extends JFrame {
  public static double pointGap = 2;
  public static double pointGapCurve = 0.5;
  public static double railWidth = 1;
  public static String switchSuffix = "_switch#";
  public static String crossSuffix = "_cross#";

  public static int width = 1000;
  public static int height = 700;
  public static double startAngle = 0;

  public JPanel panel;
  private static Map<String, String> trackCross = new HashMap<String, String>();
  private static Map<String, Double> trackCrossAngles = new HashMap<String, Double>();
  private static Map<String, map_ModelTrainSet.TrackSegment> trackPointsMap = new HashMap<String, map_ModelTrainSet.TrackSegment>();
  private static List<map_ModelTrainSet.TrackSegment> trackPoints = new ArrayList<map_ModelTrainSet.TrackSegment>();

  public static void main(String[] args) {
    map_ModelTrainSet mts = new map_ModelTrainSet();
    mts.init();
  }

  public void init() {
    trackCreation();
    trackTranslating(1);
    setTitle("ModelTrain Example Track");
    setDefaultCloseOperation(EXIT_ON_CLOSE);
    panel = new JPanel() {
      @Override
      protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
        trackDrawing(width, height, graphics);
      }
    };
    add(panel);
    panel.setPreferredSize(new Dimension(width, height));
    pack();
    setVisible(true);
  }

  public static map_ModelTrainSet.Vector3 arcCalc(double p, double r, double a) {
    map_ModelTrainSet.Vector3 center = new map_ModelTrainSet.Vector3(0, 0, r);
    map_ModelTrainSet.Vector3 point = new map_ModelTrainSet.Vector3(0, 0, p);
    double d = Math.toRadians(a);
    // x is clearly zero so the original formula can be reduced a bit: 
    double x2 = (-Math.sin(d) * (point.z - center.z));
    double y2 = (Math.cos(d) * (point.z - center.z) + center.z);
    return new map_ModelTrainSet.Vector3(x2, 0, y2);
  }

  public static map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3> rotatePoints(map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3> points, double angle, map_ModelTrainSet.Vector3 rotPoint) {
    List<map_ModelTrainSet.Vector3> p = new ArrayList<map_ModelTrainSet.Vector3>();
    p.add(points.a);
    p.add(points.b);
    p = rotatePoints(p, angle, rotPoint);
    points.a = p.get(0);
    points.b = p.get(1);
    return points;
  }

  public static List<map_ModelTrainSet.Vector3> rotatePoints(List<map_ModelTrainSet.Vector3> points, double angle, map_ModelTrainSet.Vector3 rotPoint) {
    // Rotate list of vectors around a point 
    if (angle == 0) {
      return points;
    }
    map_ModelTrainSet.Vector3 center = rotPoint;
    for (map_ModelTrainSet.Vector3 point : points) {
      double a = Math.toRadians(angle);
      double x = (Math.cos(a) * (point.x - center.x) - Math.sin(a) * (point.z - center.z) + center.x);
      double z = (Math.sin(a) * (point.x - center.x) + Math.cos(a) * (point.z - center.z) + center.z);
      point.x = x;
      point.z = z;
    }
    return points;
  }
  public static List<map_ModelTrainSet.Vector3> movePoints(List<map_ModelTrainSet.Vector3> points, map_ModelTrainSet.Vector3 offset) {
    for (int i = 0; i < points.size(); i++) {
      points.set(i, map_ModelTrainSet.Vector3.add(points.get(i), offset));
    }
    return points;
  }

  private void trackDrawing(int width, int height, Graphics g) {
    // Loop through all track pieces until all have been drawn 
    // First find range of x,y,z - y currently not used (no height) 
    double xMin = Double.MAX_VALUE;
    double xMax = Double.MIN_VALUE;
    double zMin = Double.MAX_VALUE;
    double zMax = Double.MIN_VALUE;
    for (map_ModelTrainSet.TrackSegment ts : trackPoints) {
      for (map_ModelTrainSet.Vector3 v : ts.leftPoints) {
        xMin = Math.min(v.x, xMin);
        xMax = Math.max(v.x, xMax);
        zMin = Math.min(v.z, zMin);
        zMax = Math.max(v.z, zMax);
      }
      for (map_ModelTrainSet.Vector3 v : ts.rightPoints) {
        xMin = Math.min(v.x, xMin);
        xMax = Math.max(v.x, xMax);
        zMin = Math.min(v.z, zMin);
        zMax = Math.max(v.z, zMax);
      }
    }
    topDown(xMin, xMax, zMin, zMax, width, height, g);
  }

  private void topDown(double xMin, double xMax, double zMin, double zMax, int panelW, int panelH, Graphics g) {
    // Orthogonal projection 
    double cx = -xMin;
    double cy = -zMin;
    int xOff = 10;
    int yOff = 10;
    double sx = 15;
    double sy = 15;
    g.setColor(Color.BLACK);
    for (map_ModelTrainSet.TrackSegment ts : trackPoints) {
      for (int i = 0; i < ts.leftPoints.size() - 1; i++) {
        double x1 = ts.leftPoints.get(i).x;
        double y1 = ts.leftPoints.get(i).z;
        double x2 = ts.leftPoints.get(i + 1).x;
        double y2 = ts.leftPoints.get(i + 1).z;

        int px1 = ((int) (sx * (x1 + cx))) + xOff;
        int py1 = ((int) (sy * (y1 + cy))) + yOff;
        int px2 = ((int) (sx * (x2 + cx))) + xOff;
        int py2 = ((int) (sy * (y2 + cy))) + yOff;

        g.drawLine(px1, py1, px2, py2);

        x1 = ts.rightPoints.get(i).x;
        y1 = ts.rightPoints.get(i).z;
        x2 = ts.rightPoints.get(i + 1).x;
        y2 = ts.rightPoints.get(i + 1).z;

        px1 = ((int) (sx * (x1 + cx))) + xOff;
        py1 = ((int) (sy * (y1 + cy))) + yOff;
        px2 = ((int) (sx * (x2 + cx))) + xOff;
        py2 = ((int) (sy * (y2 + cy))) + yOff;

        g.drawLine(px1, py1, px2, py2);
      }
    }
  }

  private void trackTranslating(int a) {
    Map<String, Double> angles = new HashMap<String, Double>();
    boolean started = false;
    boolean done = false;
    int doneCounter = 0;
    int doneLimit = 15;
    while (!(done) && doneCounter < doneLimit) {
      done = true;
      for (map_ModelTrainSet.TrackSegment ts : trackPoints) {
        if (angles.containsKey(ts.self)) {
          continue;
        }
        done = false;

        if (!(started)) {
          angles.put(ts.self, startAngle);
          started = true;
          continue;
        }
        String dir = "- F";
        map_ModelTrainSet.TrackSegment target;
        double angle;
        map_ModelTrainSet.Vector3 targetPositionL;
        map_ModelTrainSet.Vector3 targetPositionR;
        map_ModelTrainSet.Vector3 originPositionL;
        map_ModelTrainSet.Vector3 originPositionR;

        if (angles.containsKey(ts.from)) {
          target = trackPointsMap.get(ts.from);
          originPositionL = ts.leftPoints.get(0);
          originPositionR = ts.rightPoints.get(0);
          if (target.from.equals(ts.self)) {
            dir += "F";
            angle = 180 + angles.get(target.self);
            targetPositionL = target.rightPoints.get(0);
            targetPositionR = target.leftPoints.get(0);
          } else {
            dir += "T";
            angle = angles.get(target.self) + target.angle;
            targetPositionL = target.leftPoints.get(target.leftPoints.size() - 1);
            targetPositionR = target.rightPoints.get(target.rightPoints.size() - 1);
          }
        } else if (angles.containsKey(ts.to)) {
          dir = "- T";
          target = trackPointsMap.get(ts.to);
          originPositionL = ts.leftPoints.get(ts.leftPoints.size() - 1);
          originPositionR = ts.rightPoints.get(ts.rightPoints.size() - 1);
          if (target.to.equals(ts.self)) {
            dir += "T";
            angle = angles.get(target.self) + target.angle + 180 - ts.angle;
            targetPositionL = target.rightPoints.get(target.rightPoints.size() - 1);
            targetPositionR = target.leftPoints.get(target.leftPoints.size() - 1);
          } else {
            dir += "F";
            angle = angles.get(target.self) - ts.angle;
            targetPositionL = target.leftPoints.get(0);
            targetPositionR = target.rightPoints.get(0);
          }
        } else {
          continue;
        }
        while (angle > 360) {
          angle -= 360;
        }
        while (angle < -360) {
          angle += 360;
        }
        angles.put(ts.self, angle);

        ts.leftPoints = rotatePoints(ts.leftPoints, angle, map_ModelTrainSet.Vector3.zero);
        ts.rightPoints = rotatePoints(ts.rightPoints, angle, map_ModelTrainSet.Vector3.zero);
        map_ModelTrainSet.Vector3 offsetL = map_ModelTrainSet.Vector3.subtract(targetPositionL, originPositionL);
        map_ModelTrainSet.Vector3 offsetR = map_ModelTrainSet.Vector3.subtract(targetPositionR, originPositionR);
        ts.leftPoints = movePoints(ts.leftPoints, offsetL);
        ts.rightPoints = movePoints(ts.rightPoints, offsetR);
        print("Track: " + ts.self + dir);
        print("From: Left" + ts.leftPoints.get(0) + ", Right: " + ts.rightPoints.get(0));
        print("  To: Left" + ts.leftPoints.get(ts.leftPoints.size() - 1) + ", Right: " + ts.rightPoints.get(ts.rightPoints.size() - 1));
        print("Angle: " + angle + "," + (angle + ts.angle));

        // Handle cross and switch track 
        String tsCrossName = "";
        if (trackCross.containsKey(ts.self)) {
          tsCrossName = trackCross.get(ts.self);
        } else if (trackCross.containsValue(ts.self)) {
          tsCrossName = StringUtils.substring(ts.self, ts.self.length() - 1 - crossSuffix.length(), ts.self.length() - 1);
        }
        if (!(tsCrossName.equals(""))) {
          map_ModelTrainSet.TrackSegment tsCross = trackPointsMap.get(tsCrossName);
          tsCross.leftPoints = rotatePoints(tsCross.leftPoints, angle, map_ModelTrainSet.Vector3.zero);
          tsCross.rightPoints = rotatePoints(tsCross.rightPoints, angle, map_ModelTrainSet.Vector3.zero);
          map_ModelTrainSet.Vector3 moveTo = map_ModelTrainSet.Vector3.midPoint(ts.leftPoints.get(0), ts.rightPoints.get(0));
          tsCross.leftPoints = movePoints(tsCross.leftPoints, moveTo);
          tsCross.rightPoints = movePoints(tsCross.rightPoints, moveTo);
          angle += trackCrossAngles.get(tsCrossName);
          angles.put(tsCross.self, angle);
          angle = trackCrossAngles.get(tsCrossName);
          map_ModelTrainSet.Vector3 center = map_ModelTrainSet.Vector3.midPoint(map_ModelTrainSet.Vector3.midPoint(tsCross.leftPoints.get(0), tsCross.rightPoints.get(0)), map_ModelTrainSet.Vector3.midPoint(tsCross.leftPoints.get(tsCross.leftPoints.size() - 1), tsCross.rightPoints.get(tsCross.rightPoints.size() - 1)));
          tsCross.leftPoints = rotatePoints(tsCross.leftPoints, angle, center);
          tsCross.rightPoints = rotatePoints(tsCross.rightPoints, angle, center);
          print("Track: " + tsCross.self);
          print("From: Left" + tsCross.leftPoints.get(0) + ", Right: " + tsCross.rightPoints.get(0));
          print("  To: Left" + tsCross.leftPoints.get(tsCross.leftPoints.size() - 1) + ", Right: " + tsCross.rightPoints.get(tsCross.rightPoints.size() - 1));
          print("Angle: " + angles.get(tsCross.self));
        }

        String tsSwitchName = "";
        if (trackPointsMap.containsKey(ts.self + switchSuffix)) {
          tsSwitchName = ts.self + switchSuffix;
        } else if (trackPointsMap.containsKey(StringUtils.substring(ts.self, ts.self.length() - 1 - switchSuffix.length(), ts.self.length() - 1))) {
          tsSwitchName = StringUtils.substring(ts.self, ts.self.length() - 1 - switchSuffix.length(), ts.self.length() - 1);
        }
        if (!(tsSwitchName.equals(""))) {
          map_ModelTrainSet.TrackSegment tsSwitch = trackPointsMap.get(tsSwitchName);
          tsSwitch.leftPoints = rotatePoints(tsSwitch.leftPoints, angle, map_ModelTrainSet.Vector3.zero);
          tsSwitch.rightPoints = rotatePoints(tsSwitch.rightPoints, angle, map_ModelTrainSet.Vector3.zero);
          offsetL = map_ModelTrainSet.Vector3.subtract(ts.leftPoints.get(0), tsSwitch.leftPoints.get(0));
          offsetR = map_ModelTrainSet.Vector3.subtract(ts.rightPoints.get(0), tsSwitch.rightPoints.get(0));
          tsSwitch.leftPoints = movePoints(tsSwitch.leftPoints, offsetL);
          tsSwitch.rightPoints = movePoints(tsSwitch.rightPoints, offsetR);
          angles.put(tsSwitch.self, angles.get(ts.self));
          print("Track: " + tsSwitch.self);
          print("From: Left" + tsSwitch.leftPoints.get(0) + ", Right: " + tsSwitch.rightPoints.get(0));
          print("  To: Left" + tsSwitch.leftPoints.get(tsSwitch.leftPoints.size() - 1) + ", Right: " + tsSwitch.rightPoints.get(tsSwitch.rightPoints.size() - 1));
          print("Angle: " + angle);

        }
      }


      doneCounter += 1;
    }
  }

  private void trackTranslating() {
    // Translate and rotate track pieces into a 3D coordinate system 
    Map<String, map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3>> offsets = new HashMap<String, map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3>>();
    Map<String, map_ModelTrainSet.Pair<Double, Double>> angles = new HashMap<String, map_ModelTrainSet.Pair<Double, Double>>();
    Map<String, map_ModelTrainSet.Vector3> translationOffsets = new HashMap<String, map_ModelTrainSet.Vector3>();
    Set<String> skipSet = new HashSet<String>();
    boolean started = false;
    boolean done = false;
    int doneCounter = 0;
    int doneLimit = 15;
    while (!(done) && doneCounter < doneLimit) {
      done = true;
      for (map_ModelTrainSet.TrackSegment ts : trackPoints) {
        if (offsets.containsKey(ts.self)) {
          continue;
        }
        done = false;

        if (!(started)) {
          // Initalise starting position for first track piece at (0,0,0) 
          offsets.put(ts.self, new map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3>(map_ModelTrainSet.Vector3.zero, map_ModelTrainSet.Vector3.midPoint(ts.leftPoints.get(ts.leftPoints.size() - 1), ts.rightPoints.get(ts.rightPoints.size() - 1))));
          started = true;
          map_ModelTrainSet.Pair<Double, Double> anglePair = new map_ModelTrainSet.Pair<Double, Double>(0.0, 0.0);
          if (ts.angle != 0) {
            anglePair.b = ts.angle;
          }
          angles.put(ts.self, anglePair);
          translationOffsets.put(ts.self, offsets.get(ts.self).a);
          continue;
        }

        map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3> offset = new map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3>(map_ModelTrainSet.Vector3.zero, map_ModelTrainSet.Vector3.zero);
        map_ModelTrainSet.Pair<Double, Double> targetAngles;
        map_ModelTrainSet.Pair<Double, Double> selfAngles;

        // Calculate this tracks position based on connected pieces that have already been processed 
        // Results are slightly different based on whether the connected piece is "from" or "to" 
        double rotationAngle;
        map_ModelTrainSet.Vector3 rotatePoint = map_ModelTrainSet.Vector3.zero;
        if (offsets.containsKey(ts.from)) {
          targetAngles = angles.get(ts.from);
          selfAngles = new map_ModelTrainSet.Pair<Double, Double>(targetAngles.b, targetAngles.b + ts.angle);
          print(ts.self + ") from - Angle " + selfAngles.a + "," + selfAngles.b);
          rotationAngle = selfAngles.a;
          ts.leftPoints = rotatePoints(ts.leftPoints, rotationAngle, map_ModelTrainSet.Vector3.zero);
          ts.rightPoints = rotatePoints(ts.rightPoints, rotationAngle, map_ModelTrainSet.Vector3.zero);
          offset.a = offsets.get(ts.from).b;
          offset.b = map_ModelTrainSet.Vector3.add(offset.a, map_ModelTrainSet.Vector3.midPoint(ts.leftPoints.get(ts.leftPoints.size() - 1), ts.rightPoints.get(ts.rightPoints.size() - 1)));
          translationOffsets.put(ts.self, offset.a);
          print("from - Offset " + offset.a + "," + offset.b);
        } else if (offsets.containsKey(ts.to)) {
          targetAngles = angles.get(ts.to);
          selfAngles = new map_ModelTrainSet.Pair<Double, Double>(targetAngles.a - ts.angle, targetAngles.a);
          print(ts.self + ") to - Angle " + selfAngles.a + "," + selfAngles.b);
          rotatePoint = map_ModelTrainSet.Vector3.midPoint(ts.leftPoints.get(ts.leftPoints.size() - 1), ts.rightPoints.get(ts.rightPoints.size() - 1));
          rotationAngle = selfAngles.a;
          ts.leftPoints = rotatePoints(ts.leftPoints, rotationAngle, rotatePoint);
          ts.rightPoints = rotatePoints(ts.rightPoints, rotationAngle, rotatePoint);
          offset.b = offsets.get(ts.to).a;
          offset.a = map_ModelTrainSet.Vector3.subtract(offset.b, rotatePoint);
          translationOffsets.put(ts.self, offset.a);
          print("to - Offset " + offset.a + "," + offset.b);
        } else {
          continue;
        }
        angles.put(ts.self, selfAngles);
        offsets.put(ts.self, offset);

        // This fixes the potential problem created by a crossing that creates a disconnected track 
        String tsCrossName = "";
        if (trackCross.containsKey(ts.self)) {
          tsCrossName = trackCross.get(ts.self);
        } else if (trackCross.containsValue(ts.self)) {
          tsCrossName = StringUtils.substring(ts.self, ts.self.length() - 1 - crossSuffix.length(), ts.self.length() - 1);
        }
        if (!(tsCrossName.equals(""))) {
          double angle = trackCrossAngles.get(tsCrossName);
          print(angle + tsCrossName);
          angles.put(tsCrossName, new map_ModelTrainSet.Pair<Double, Double>(angle + rotationAngle, angle + rotationAngle));
          offsets.put(tsCrossName, new map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3>(new map_ModelTrainSet.Vector3(offset.a.x, offset.a.y, offset.a.z), new map_ModelTrainSet.Vector3(offset.b.x, offset.b.y, offset.b.z)));
          for (map_ModelTrainSet.TrackSegment ts2 : trackPoints) {
            if (ts2.self.equals(tsCrossName)) {
              map_ModelTrainSet.Vector3 mid;
              mid = map_ModelTrainSet.Vector3.midPoint(map_ModelTrainSet.Vector3.midPoint(ts2.leftPoints.get(0), ts2.rightPoints.get(0)), map_ModelTrainSet.Vector3.midPoint(ts2.leftPoints.get(ts2.leftPoints.size() - 1), ts2.rightPoints.get(ts2.rightPoints.size() - 1)));

              ts2.leftPoints = rotatePoints(ts2.leftPoints, angle, rotatePoint);
              ts2.rightPoints = rotatePoints(ts2.rightPoints, angle, rotatePoint);
              map_ModelTrainSet.Pair<map_ModelTrainSet.Vector3, map_ModelTrainSet.Vector3> offset2 = offsets.get(tsCrossName);
              for (int i = 0; i < ts2.leftPoints.size(); i++) {
                ts2.leftPoints.set(i, map_ModelTrainSet.Vector3.add(ts2.leftPoints.get(i), offset2.a));
                ts2.rightPoints.set(i, map_ModelTrainSet.Vector3.add(ts2.rightPoints.get(i), offset2.a));
              }
              mid = map_ModelTrainSet.Vector3.midPoint(map_ModelTrainSet.Vector3.midPoint(ts2.leftPoints.get(0), ts2.rightPoints.get(0)), map_ModelTrainSet.Vector3.midPoint(ts2.leftPoints.get(ts2.leftPoints.size() - 1), ts2.rightPoints.get(ts2.rightPoints.size() - 1)));
              offset2 = rotatePoints(offset2, angle, mid);
              skipSet.add(ts2.self);
              break;
            }
          }
        }

      }
      doneCounter += 1;
    }
    // Apply offsets 
    for (map_ModelTrainSet.TrackSegment ts : trackPoints) {
      if (ts == null || !(offsets.containsKey(ts.self)) || skipSet.contains(ts.self)) {
        continue;
      }
      map_ModelTrainSet.Vector3 offset = translationOffsets.get(ts.self);
      print("Track: " + ts.self);
      for (int i = 0; i < ts.leftPoints.size(); i++) {
        ts.leftPoints.set(i, map_ModelTrainSet.Vector3.add(ts.leftPoints.get(i), offset));
        ts.rightPoints.set(i, map_ModelTrainSet.Vector3.add(ts.rightPoints.get(i), offset));
      }
      print("From left: " + ts.leftPoints.get(0) + " " + ", right: " + ts.rightPoints.get(0));
      print("  To left: " + ts.leftPoints.get(ts.leftPoints.size() - 1) + " " + ", right: " + ts.rightPoints.get(ts.rightPoints.size() - 1));
      print("Offset: " + offsets.get(ts.self).a + "," + offsets.get(ts.self).b);
      print("Angles: " + angles.get(ts.self).a + "," + angles.get(ts.self).b);
    }
  }


  /**
   * Helper methods and classes, and lastly code generated from track structures
   */
  public static void print(Object o) {
    System.out.println(o.toString());
  }


  public static void addTrackCross(String t1, String t2, double angle) {
    trackCross.put(t1, t2);
    trackCrossAngles.put(t1, -angle);
    trackCrossAngles.put(t2, angle);
  }

  public static void addTrackSegment(String self, List<map_ModelTrainSet.Vector3> leftPoints, List<map_ModelTrainSet.Vector3> rightPoints, String from, String to, double angle) {
    map_ModelTrainSet.TrackSegment s = new map_ModelTrainSet.TrackSegment(self, leftPoints, rightPoints, from, to, angle);
    trackPoints.add(s);
    trackPointsMap.put(self, s);
  }
  public static void addTrackSegment(String self, List<map_ModelTrainSet.Vector3> leftPoints, List<map_ModelTrainSet.Vector3> rightPoints, String from, String to) {
    addTrackSegment(self, leftPoints, rightPoints, from, to, 0);
  }

  public class Pair<A, B> {
    public A a;
    public B b;
    public Pair(A a, B b) {
      this.a = a;
      this.b = b;
    }
  }

  public static class Vector3 {
    public double x;
    public double y;
    public double z;
    public Vector3(double x, double y, double z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    public static final map_ModelTrainSet.Vector3 zero = new map_ModelTrainSet.Vector3(0, 0, 0);
    public map_ModelTrainSet.Vector3 subtract(map_ModelTrainSet.Vector3 other) {
      return new map_ModelTrainSet.Vector3(x - other.x, y - other.y, z - other.z);
    }
    public static map_ModelTrainSet.Vector3 midPoint(map_ModelTrainSet.Vector3 a, map_ModelTrainSet.Vector3 b) {
      return new map_ModelTrainSet.Vector3((a.x + b.x) * 0.5f, (a.y + b.y) * 0.5f, (a.z + b.z) * 0.5f);
    }
    public static map_ModelTrainSet.Vector3 add(map_ModelTrainSet.Vector3 a, map_ModelTrainSet.Vector3 b) {
      return new map_ModelTrainSet.Vector3(b.x + a.x, b.y + a.y, b.z + a.z);
    }
    public static map_ModelTrainSet.Vector3 subtract(map_ModelTrainSet.Vector3 a, map_ModelTrainSet.Vector3 b) {
      return new map_ModelTrainSet.Vector3(a.x - b.x, a.y - b.y, a.z - b.z);
    }
    @Override
    public String toString() {
      return "(" + x + "," + y + "," + z + ")";
    }
  }

  public static class TrackSegment {
    public String self;
    public List<map_ModelTrainSet.Vector3> leftPoints;
    public List<map_ModelTrainSet.Vector3> rightPoints;
    public String from;
    public String to;
    public double angle;
    public TrackSegment(String self, List<map_ModelTrainSet.Vector3> leftPoints, List<map_ModelTrainSet.Vector3> rightPoints, String from, String to, double angle) {
      this.self = self;
      this.leftPoints = leftPoints;
      this.rightPoints = rightPoints;
      this.from = from;
      this.to = to;
      this.angle = angle;
    }
  }


  private void trackCreation() {
    // Turns track pieces into sets of 3d positions 
  }
}
